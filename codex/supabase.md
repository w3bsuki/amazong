
> Execution Status: Reference Only
> This playbook is an input reference. Active execution tracking lives in codex/master-refactor-plan.md and codex/phases/*.md.

# Task: Supabase Data Layer Audit & Refactor

> **Read `codex/AGENTS.md` first.** It contains the project context, folder map, non-negotiables, and verification gates.

## Objective

Clean up the Supabase data layer. Eliminate wildcard selects, consolidate repeated select strings into shared constants, remove dead queries, fix error handling, and centralize data access patterns. DO NOT modify migrations, RLS policies, or auth configuration — those are out of scope. Flag any security concerns for human review.

---

## PAUSE RULE (MANDATORY)

**Do NOT modify any of the following without explicit human approval:**
- Supabase migration files (`supabase/migrations/`)
- RLS policies (via SQL or Supabase dashboard)
- Auth configuration (providers, session handling, tokens)
- Edge Functions (`supabase/functions/`)

You MAY read and audit these files. You MAY flag issues. You MUST NOT change them.

---

## Phase 1: Wildcard Select Elimination

### 1.1 Find All `.select('*')` and `.select()` Calls

```bash
grep -rn "\.select(\s*['\"]\\*['\"])" --include="*.ts" --include="*.tsx" app/ lib/
grep -rn "\.select(\s*)" --include="*.ts" --include="*.tsx" app/ lib/
```

Also check for:
```bash
grep -rn "\.select(" --include="*.ts" --include="*.tsx" app/ lib/ | grep -v "\.select('" | grep -v "\.select(\`"
```

This catches `.select()` calls with no arguments (which Supabase treats as `select *`).

For each wildcard select:
1. Determine which columns the consumer actually uses.
2. Replace `select('*')` with an explicit column list: `select('id, name, price, created_at')`.
3. Use constants from `lib/supabase/selects/` if the same select pattern is used in multiple places.

### 1.2 Build Select Constants

Check what already exists in `lib/supabase/selects/`:

```bash
ls lib/supabase/selects/
```

For each data entity (products, categories, profiles, orders, etc.), there should be ONE canonical select constant defining the columns needed. Pattern:

```typescript
// lib/supabase/selects/products.ts
export const PRODUCT_LIST_SELECT = 'id, title, price, images, condition, created_at, category_id, seller_id' as const;
export const PRODUCT_DETAIL_SELECT = 'id, title, price, description, images, condition, ...' as const;
```

Create missing select constants. Replace all inline select strings with these constants.

---

## Phase 2: Data Access Layer Audit

### 2.1 `lib/data/` — Server-Side Data Fetching

Currently contains 7 files:
```
lib/data/
  categories.ts
  category-attributes.ts
  plans.ts
  product-page.ts
  product-reviews.ts
  products.ts
  profile-page.ts
```

For each file:
1. Read it and understand what queries it contains.
2. Verify every exported function is imported somewhere (check with grep).
3. Delete unused functions.
4. Ensure all queries use explicit select strings (no wildcards).
5. Check error handling — all Supabase queries should handle `.error` returns.
6. Check for `.single()` vs `.maybeSingle()` usage — use `.maybeSingle()` when the record might not exist (avoids throwing on empty results).

### 2.2 `lib/supabase/` — Client & Utilities

```
lib/supabase/
  AGENTS.md
  client.ts
  database.types.ts
  messages.ts
  middleware.ts
  selects/
  server.ts
  shared.ts
```

- `client.ts` + `server.ts` — Supabase client factories. Verify they're used correctly (server client in Server Components/actions, browser client in Client Components).
- `middleware.ts` — Supabase session middleware. Verify it's used by `proxy.ts` (the request hook).
- `shared.ts` — Shared utilities. Audit for unused exports.
- `messages.ts` — Message/conversation queries. Verify it's used. If the `(chat)/` route uses it, keep. If nothing imports it, delete.
- `database.types.ts` — Auto-generated types. DO NOT edit this file manually. Verify it's up-to-date by checking the last generation date (there should be a comment at the top).

### 2.3 `app/actions/` — Server Actions with Supabase

All 13 action files interact with Supabase. For each:
1. Verify all Supabase calls use explicit selects.
2. Check for proper auth checks (every mutation should verify the user is authenticated).
3. Check for proper error handling (return structured errors, don't swallow failures).
4. Remove duplicate auth-check boilerplate — if 10 actions all start with the same `getUser()` + auth check pattern, extract to a shared helper in `lib/auth/`.

---

## Phase 3: Type Safety for Supabase Queries

### 3.1 Verify `database.types.ts` Usage

All Supabase queries should be typed via the generated types:

```typescript
import { Database } from '@/lib/supabase/database.types';
type Product = Database['public']['Tables']['products']['Row'];
```

Search for manually-defined types that duplicate what's in `database.types.ts`:

```bash
grep -rn "type.*Product\s*=" --include="*.ts" --include="*.tsx" app/ components/ lib/ | grep -v database.types
grep -rn "interface.*Product\s*{" --include="*.ts" --include="*.tsx" app/ components/ lib/ | grep -v database.types
```

If manual types duplicate the auto-generated ones, delete the manual types and import from `database.types.ts`. Custom view models or DTOs that ADD fields or TRANSFORM shape are fine — those belong in `lib/types/` or `lib/view-models/`.

### 3.2 Check `lib/types/` for Supabase Overlaps

```
lib/types/
  badges.ts
  categories.ts
  messages.ts
  products.ts
```

For each file, check if the types are:
1. Exact copies of `database.types.ts` types → delete and use the generated type
2. Subsets of database types (DTOs) → keep but derive from the generated type using `Pick<>`
3. View models with computed fields → keep in `lib/view-models/`
4. Completely unused → delete

### 3.3 Check `lib/view-models/`

```
lib/view-models/
  product-page.ts
```

Only 1 file. Verify it's used and properly derives from database types.

---

## Phase 4: Query Pattern Audit

### 4.1 Unbounded Queries

Search for queries without `.limit()`:

```bash
grep -rn "\.from(" --include="*.ts" --include="*.tsx" app/ lib/ | grep -v "\.limit(" | grep -v "\.single(" | grep -v "\.maybeSingle("
```

Every list query should have a reasonable limit (e.g., `.limit(50)` or `.range(from, to)`) to prevent accidentally fetching the entire table. Add limits where missing.

### 4.2 Missing Error Checks

```bash
grep -rn "\.from(" --include="*.ts" --include="*.tsx" app/ lib/
```

For each query, verify the code checks the `.error` property or uses a pattern like:
```typescript
const { data, error } = await supabase.from('table').select('...');
if (error) throw error; // or return error response
```

Find queries where the error is ignored (destructured but never checked, or not destructured at all).

### 4.3 Supabase Client Selection

Verify correct client usage:
- **Server Components** (RSC): Must use `createClient()` from `lib/supabase/server.ts`
- **Client Components**: Must use `createBrowserClient()` from `lib/supabase/client.ts`
- **Server Actions**: Must use the server client
- **API Route Handlers**: Must use the server client
- **Middleware**: Must use the middleware-specific client

Search for incorrect usage:
```bash
grep -rn "createBrowserClient\|createClient" --include="*.ts" --include="*.tsx" app/ lib/
```

Verify each import matches the component type (server vs client).

---

## Phase 5: Edge Functions Audit

### 5.1 `supabase/functions/ai-shopping-assistant/`

This is the only Edge Function. DO NOT modify it without human approval, but audit:
1. Check if it's deployed and active.
2. Check if `app/api/assistant/` or `app/[locale]/(main)/assistant/` calls it.
3. If it's not called from anywhere in the app, flag it as potentially dead.
4. Note: It has `@ts-nocheck` (addressed in `typescript.md` task). Don't duplicate that work here.

### 5.2 Seed Files

- `supabase/seed.sql` — Verify it contains sensible seed data (no test junk that could leak to production).
- `supabase/seed_categories.sql` — Category seed data. Verify it matches the actual category structure.
- `supabase/schema.sql` — Schema dump. Verify it's up to date (or note that it might not be since migrations are the SSOT).

---

## Phase 6: Data Access Consolidation

### 6.1 Scattered Supabase Queries

Check for Supabase `.from()` calls in places they shouldn't be:

```bash
grep -rn "supabase.*\.from(" --include="*.tsx" components/
```

Components should NOT make Supabase calls directly. Data fetching belongs in:
- `lib/data/` (Server Components)
- `app/actions/` (mutations)
- `app/api/` (API routes)
- `hooks/` (client-side queries via the browser client — these are acceptable but should be minimal)

If components are fetching data, refactor: move the query to the appropriate location and pass data as props.

### 6.2 Duplicate Queries

Search for the same table being queried from multiple locations with the same select/filter pattern:

```bash
grep -rn "from('products')" --include="*.ts" --include="*.tsx" app/ lib/
grep -rn "from('categories')" --include="*.ts" --include="*.tsx" app/ lib/
grep -rn "from('profiles')" --include="*.ts" --include="*.tsx" app/ lib/
```

If the same query (same table + same select + same filters) exists in 2+ places, extract to a shared function in `lib/data/`.

---

## Verification

After all changes:

```bash
pnpm -s typecheck
pnpm -s lint
pnpm -s test:unit
REUSE_EXISTING_SERVER=true pnpm -s test:e2e:smoke
```

---

## Completion Criteria

- Zero `select('*')` or `select()` (no-arg) calls in the codebase
- All repeated select strings centralized in `lib/supabase/selects/`
- No components making direct Supabase calls (all data access through `lib/data/`, `app/actions/`, `app/api/`, or dedicated hooks)
- Every Supabase query checks the error return
- Every list query has a `.limit()` or `.range()`
- No manually-duplicated types that exist in `database.types.ts`
- Correct Supabase client used in every context (server/browser/middleware)
- All unused data functions deleted
- All gates pass
