# AUTH.md — Auth Domain Contract

> Supabase Auth implementation notes: sessions, route protection, onboarding gating, and security gotchas.

| Field | Value |
|-------|-------|
| Owner | treido-orchestrator |
| Last verified | 2026-02-13 |
| Refresh cadence | Weekly + whenever auth flow changes |

## Scope

Authentication, sessions, route protection, onboarding gating, and account lifecycle behavior.

## Runtime Truth Paths

- `proxy.ts` (middleware entry point: i18n + geo + session update)
- `lib/supabase/middleware.ts` (session update + protected-route redirects)
- `lib/supabase/server.ts` (server, static, route-handler, admin Supabase clients)
- `lib/supabase/client.ts` (browser Supabase client + fresh client)
- `lib/auth/require-auth.ts` (server action auth helpers; `getUser()` only)
- `lib/auth/admin.ts`, `lib/auth/business.ts` (role/tier gating helpers)
- `components/providers/auth-state-manager.tsx` (client auth state + refresh strategy)
- `app/auth/confirm/route.ts` (email confirm PKCE/token hash exchange)
- `app/api/auth/sign-out/route.ts` (sign-out endpoint; GET is non-mutating)
- `app/[locale]/(auth)/**` (login/signup/reset pages + actions)
- `app/[locale]/(onboarding)/**` (onboarding wizard routes)
- `app/[locale]/(main)/_providers/onboarding-provider.tsx` (onboarding redirect logic)

## Quick Reference (How Auth Actually Works)

| Concern | Runtime behavior |
|--------|------------------|
| Session storage | HTTP-only cookies via `@supabase/ssr` server clients |
| Server auth check | `supabase.auth.getUser()` (never `getSession()` for security checks) |
| Client state | `AuthStateManager` reads session and listens to `onAuthStateChange` |
| Session refresh | Middleware updates session for protected paths; client forces refresh when leaving `/auth` |
| Onboarding gating | Client-side `OnboardingProvider` redirects incomplete users to `/${locale}/onboarding` |

## Security Non-Negotiables

- **Never** use `getSession()` to authorize server-side behavior. Use `supabase.auth.getUser()` (`lib/auth/require-auth.ts` and middleware follow this).
- Webhooks/admin flows use `createAdminClient()` (service role) only after verifying the request is trusted (e.g. Stripe signature).
- Sign-out must be **POST** for mutating behavior; `GET` is redirect-only to reduce CSRF risk (`app/api/auth/sign-out/route.ts`).
- Redirect targets must be validated (see `safeNextPath()` in `app/auth/confirm/route.ts`).

## Session Lifecycle + Refresh Strategy

### Server (Middleware)

- `proxy.ts` runs for app routes and calls `updateSession()` from `lib/supabase/middleware.ts`.
- `updateSession()` only performs an auth check for likely-authenticated surfaces (account/sell/chat + legacy `/protected`) to reduce edge load.

### Client (AuthStateManager)

`components/providers/auth-state-manager.tsx` handles the cases middleware can’t cover:

- Reads session on first load.
- Listens to `supabase.auth.onAuthStateChange()` to keep the app state consistent.
- Forces a refresh when navigating away from `/auth/*` routes (server actions can write cookies without triggering client events).
- Periodically refreshes in the background for authenticated users (interval + tab visibility), with throttling.

## Route Protection (Current Behavior)

Middleware redirects unauthenticated users to `/${locale}/auth/login?next=...` for:

- `/${locale}/account/*`
- `/${locale}/sell/orders/*`
- legacy `/protected*` (locale-aware)

Other “must be authed” surfaces should still enforce auth in Server Components/actions using `requireAuth()` / `requireAuthOrFail()` / `requireAdmin()` / `requireDashboardAccess()`.

## Onboarding Dependencies

Onboarding completeness is tracked via `profiles.onboarding_completed`:

- `OnboardingProvider` reads `profiles.onboarding_completed` and redirects to `/${locale}/onboarding` unless the current route is in its bypass list (search/cart/categories/etc).
- `app/auth/confirm/route.ts` redirects new users to `/${locale}/?onboarding=true` after email confirmation when onboarding is incomplete.

## Common Gotchas

- **Route handlers** (`app/api/*`) should use `createRouteHandlerClient(request)` (not `cookies()` from `next/headers`).
- **Cached reads** must use `createStaticClient()` and must not touch cookies/headers (see `ARCHITECTURE.md` caching rules).
- If you add new protected surfaces, decide explicitly whether middleware should redirect (edge cost) vs server-side gating (simpler semantics).

## Verification

- Baseline: `pnpm -s typecheck && pnpm -s lint && pnpm -s styles:gate`
- Flow coverage: `pnpm -s test:e2e:auth`

## Deep Dive

- Pre-cutover full reference: `docs/archive/2026-02-doc-reset/pre-cutover-docs/AUTH.md` (`docs/archive/2026-02-doc-reset/pre-cutover-docs/AUTH.md`)

## See Also

- [`ARCHITECTURE.md`](../../ARCHITECTURE.md)
- [`docs/RISK.md`](/risk)
- [`REQUIREMENTS.md`](../../REQUIREMENTS.md)

*Last updated: 2026-02-13*

