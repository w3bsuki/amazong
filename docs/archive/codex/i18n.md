
> Execution Status: Reference Only
> This playbook is an input reference. Active execution tracking lives in codex/master-refactor-plan.md and codex/phases/*.md.

# Task: Internationalization (i18n) Audit & Refactor

> **Read `codex/AGENTS.md` first.** It contains the project context, folder map, non-negotiables, and verification gates.

## Objective

Clean up the i18n system. Delete unused translation keys from both locale files. Find and migrate hardcoded user-facing strings. Consolidate duplicate translation values. Ensure parity between `en.json` and `bg.json`. The existing parity test (`__tests__/i18n-messages-parity.test.ts`) must pass after all changes.

---

## Phase 1: Unused Key Detection

### 1.1 Build a Key Inventory

Parse `messages/en.json` to get a flat list of all translation keys. The JSON is nested, so keys look like `Namespace.subkey.deeperKey`.

### 1.2 Search for Each Key in the Codebase

For each translation key, check if it's referenced anywhere in `app/`, `components/`, `lib/`, or `hooks/`:

**Static key usage patterns:**
```typescript
t('Namespace.key')
t("Namespace.key")
t(`Namespace.key`)
```

**Dynamic key usage patterns (DO NOT delete these keys):**
```typescript
t(`Condition.${condition}`)
t(`Category.${slug}`)
t(`OrderStatus.${status}`)
t(`Sort.${value}`)
```

For dynamic patterns, identify the namespace being dynamically accessed and preserve ALL keys in that namespace.

**Namespace access patterns:**
```typescript
const t = useTranslations('Namespace');
t('key')                    // Resolves to "Namespace.key"
```

When `useTranslations('Namespace')` is used, the `t('key')` calls reference `Namespace.key` — account for this indirection.

### 1.3 Delete Confirmed Unused Keys

For each key that has ZERO references in the codebase (accounting for dynamic access):
1. Delete the key from `messages/en.json`
2. Delete the matching key from `messages/bg.json`
3. Always delete from both files simultaneously to maintain parity.

Work in batches of 10-20 keys. Run the parity test after each batch:

```bash
pnpm -s test:unit -- --testPathPattern=i18n-messages-parity
```

---

## Phase 2: Parity Audit

### 2.1 Find Keys Present in One File But Not the Other

```bash
pnpm -s test:unit -- --testPathPattern=i18n-messages-parity
```

If this test fails, it will show which keys are missing from which locale. Fix parity:
- If a key exists in `en.json` but not `bg.json`: Add the key to `bg.json` with the Bulgarian translation (or a TODO marker if you can't translate).
- If a key exists in `bg.json` but not `en.json`: The English version was probably deleted. Delete it from `bg.json` too.

### 2.2 Structural Parity

Beyond key names, ensure the JSON structure matches:
- Same nesting hierarchy
- Same key ordering within each namespace (for diff readability)
- No orphaned empty objects `{}` or empty strings `""`

---

## Phase 3: Hardcoded String Detection

### 3.1 Find Hardcoded User-Facing Strings in TSX

Search for text content in JSX that's not wrapped in `t()`:

```bash
grep -rn ">[A-Z][a-z]" --include="*.tsx" app/ components/ | grep -v "import\|from\|//\|className\|const\|type\|interface\|export\|return\|throw\|console\|aria-\|data-\|role="
```

This is a noisy search. Focus on:
1. **Visible text in JSX** — headings, paragraphs, button labels, links, placeholder text
2. **Toast messages** — `toast.success('...')`, `toast.error('...')`
3. **Alert/confirmation dialogs** — hardcoded dialog titles and descriptions
4. **Form labels and placeholders** — `<Input placeholder="Search..." />`
5. **Error messages** shown to users — `<p>Something went wrong</p>`

Ignore:
- Technical strings (API endpoints, CSS classes, data attributes)
- Console logs (not user-facing)
- Type definitions and constants
- Comments

### 3.2 Migrate to next-intl

For each hardcoded string found:
1. Add the key to the appropriate namespace in `messages/en.json`
2. Add the Bulgarian translation to `messages/bg.json` (use the Bulgarian value if you can determine it from existing patterns, otherwise add a placeholder like `"[TODO: BG translation]"`)
3. Replace the hardcoded string with `t('Namespace.key')`
4. If the component isn't already using `useTranslations`, add the hook

---

## Phase 4: Duplicate Value Consolidation

### 4.1 Find Duplicate String Values

Parse `messages/en.json` and find keys that have identical string values. Common duplicates:
- "Close", "Cancel", "Save", "Delete", "Confirm", "Back", "Next", "Submit"
- "Loading...", "Error", "Success"
- "All", "None", "Other"

### 4.2 Evaluate Consolidation

Not all duplicate values should be consolidated. Guidelines:
- **Consolidate** when the string has the same semantic meaning everywhere (e.g., "Close" on a modal = "Close" on a drawer = same concept)
- **Keep separate** when the string might diverge in the future or has different context (e.g., "Save" for a form vs "Save" for bookmarking — these might need different translations in some languages)

For strings that should be consolidated:
1. Create a `Common` namespace in the message files: `Common.close`, `Common.cancel`, `Common.save`, etc.
2. Update all usages to reference the common key
3. Delete the old duplicate keys

---

## Phase 5: i18n Infrastructure Audit

### 5.1 `i18n/` Folder

```
i18n/
  AGENTS.md
  request.ts
  routing.ts
```

Read each file:
- `request.ts` — next-intl request configuration. Verify it's minimal and correct.
- `routing.ts` — Locale routing configuration. Verify supported locales match the message files.
- `AGENTS.md` — Local agents config. Keep or update.

### 5.2 Locale Providers

Check `app/[locale]/_providers/intl-client-provider.tsx`:
- Verify it correctly provides messages to Client Components
- Check if it's loading the full message bundle or a subset (performance consideration)

### 5.3 Message File Size

After cleanup, check the sizes of `en.json` and `bg.json`. If they're very large (>100KB), consider whether next-intl's message splitting is configured to avoid loading all messages on every page.

---

## Phase 6: Message File Formatting

### 6.1 Sort Keys Alphabetically

Within each namespace, sort keys alphabetically for easier diffing and finding:

```json
{
  "Common": {
    "back": "Back",
    "cancel": "Cancel",
    "close": "Close",
    "save": "Save"
  }
}
```

### 6.2 Remove Empty Values

Find and handle entries with empty string values:
```bash
grep -n '""' messages/en.json
grep -n '""' messages/bg.json
```

If a key has an empty string value, either provide the proper translation or delete the key.

---

## Verification

After all changes:

```bash
pnpm -s test:unit -- --testPathPattern=i18n-messages-parity   # Parity test
pnpm -s typecheck                                              # Type check
pnpm -s lint                                                   # Lint
pnpm -s test:unit                                              # All unit tests
```

---

## Completion Criteria

- `i18n-messages-parity.test.ts` passes (all keys present in both locale files)
- Zero unused keys in `en.json` / `bg.json` (accounting for dynamic access patterns)
- Zero hardcoded user-facing strings in TSX files (all migrated to next-intl)
- Common strings consolidated into a `Common` namespace
- No empty string values in message files
- Keys sorted alphabetically within each namespace
- All gates pass
